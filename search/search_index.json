{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"whiteboxgui","text":"<p>An interactive GUI for WhiteboxTools in a Jupyter-based environment</p> <ul> <li>GitHub repo: https://github.com/opengeos/whiteboxgui</li> <li>Documentation: https://opengeos.github.io/whiteboxgui</li> <li>PyPI: https://pypi.org/project/whiteboxgui</li> <li>conda-forge: https://anaconda.org/conda-forge/whiteboxgui</li> <li>WhiteboxTools: https://github.com/jblindsay/whitebox-tools</li> <li>User Manual: https://www.whiteboxgeo.com/manual/wbt_book</li> <li>whitebox-python: https://github.com/opengeos/whitebox-python</li> <li>whiteboxR: https://github.com/opengeos/whiteboxR</li> <li>whitebox-ArcGIS: https://github.com/opengeos/WhiteboxTools-ArcGIS</li> <li>Free software: MIT license</li> </ul>"},{"location":"#description","title":"Description","text":"<p>The whiteboxgui Python package is a Jupyter frontend for WhiteboxTools, an advanced geospatial data analysis platform developed by Prof. John Lindsay (webpage; jblindsay) at the University of Guelph's Geomorphometry and Hydrogeomatics Research Group. WhiteboxTools can be used to perform common geographical information systems (GIS) analysis operations, such as cost-distance analysis, distance buffering, and raster reclassification. Remote sensing and image processing tasks include image enhancement (e.g. panchromatic sharpening, contrast adjustments), image mosaicing, numerous filtering operations, simple classification (k-means), and common image transformations. WhiteboxTools also contains advanced tooling for spatial hydrological analysis (e.g. flow-accumulation, watershed delineation, stream network analysis, sink removal), terrain analysis (e.g. common terrain indices such as slope, curvatures, wetness index, hillshading; hypsometric analysis; multi-scale topographic position analysis), and LiDAR data processing. LiDAR point clouds can be interrogated (LidarInfo, LidarHistogram), segmented, tiled and joined, analyized for outliers, interpolated to rasters (DEMs, intensity images), and ground-points can be classified or filtered. WhiteboxTools is not a cartographic or spatial data visualization package; instead it is meant to serve as an analytical backend for other data visualization software, mainly GIS.</p> <p>The WhiteboxTools currently contains 518 tools, which are each grouped based on their main function into one of the following categories: Data Tools, GIS Analysis, Hydrological Analysis, Image Analysis, LiDAR Analysis, Mathematical and Statistical Analysis, Stream Network Analysis, and Terrain Analysis. For a listing of available tools, complete with documentation and usage details, please see the WhiteboxTools User Manual.</p>"},{"location":"#installation","title":"Installation","text":"<p>The whiteboxgui Python package can be installed using the following command:</p> <pre><code>pip install whiteboxgui\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The whiteboxgui provides a Graphical User Interface (GUI) for WhiteboxTools in a Jupyter-based environment, which can be invoked using the following Python script:</p> <pre><code>import whiteboxgui\nwhiteboxgui.show(verbose=True)\n</code></pre> <p></p>"},{"location":"#demo","title":"Demo","text":""},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the giswqs/pypackage project template.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/opengeos/whiteboxgui/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>whiteboxgui could always use more documentation, whether as part of the official whiteboxgui docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/opengeos/whiteboxgui/issues</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up whiteboxgui for local development.</p> <ol> <li> <p>Fork the whiteboxgui repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <p><code>shell $ git clone git@github.com:your_name_here/whiteboxgui.git</code></p> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <p><code>shell $ mkvirtualenv whiteboxgui $ cd whiteboxgui/ $ python setup.py develop</code></p> </li> <li> <p>Create a branch for local development:</p> <p><code>shell $ git checkout -b name-of-your-bugfix-or-feature</code></p> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <p><code>shell $ flake8 whiteboxgui tests $ python setup.py test or pytest $ tox</code></p> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <p><code>shell $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature</code></p> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/opengeos/whiteboxgui/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install whiteboxgui, run this command in your terminal:</p> <pre><code>pip install whiteboxgui\n</code></pre> <p>This is the preferred method to install whiteboxgui, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for whiteboxgui can be downloaded from the Github repo.</p> <p>You can clone the public repository:</p> <pre><code>git clone git://github.com/opengeos/whiteboxgui\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use whiteboxgui in a project:</p> <pre><code>import whiteboxgui\nwhiteboxgui.show(verbose=True)\n</code></pre> <p></p> <p></p>"},{"location":"whiteboxgui/","title":"whiteboxgui module","text":"<p>Main module.</p>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.build_toolbox","title":"<code>build_toolbox(tools_dict, max_width='1080px', max_height='600px', sandbox_path=None)</code>","text":"<p>Build the toolbox for WhiteboxTools.</p> <p>Parameters:</p> Name Type Description Default <code>tools_dict</code> <code>dict</code> <p>A dictionary containing information for all tools.</p> required <code>max_width</code> <code>str</code> <p>The maximum width of the widget.</p> <code>'1080px'</code> <code>max_height</code> <code>str</code> <p>The maximum height of the widget.</p> <code>'600px'</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox folder. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget representing the toolbox.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def build_toolbox(\n    tools_dict, max_width=\"1080px\", max_height=\"600px\", sandbox_path=None\n):\n\"\"\"Build the toolbox for WhiteboxTools.\n\n    Args:\n        tools_dict (dict): A dictionary containing information for all tools.\n        max_width (str, optional): The maximum width of the widget.\n        max_height (str, optional): The maximum height of the widget.\n        sandbox_path (str, optional): The path to the sandbox folder. Defaults to None.\n\n    Returns:\n        object: An ipywidget representing the toolbox.\n    \"\"\"\n    left_widget = widgets.VBox(layout=widgets.Layout(min_width=\"175px\"))\n    center_widget = widgets.VBox(\n        layout=widgets.Layout(min_width=\"200px\", max_width=\"200px\")\n    )\n    right_widget = widgets.Output(\n        layout=widgets.Layout(width=\"630px\", max_height=max_height)\n    )\n    full_widget = widgets.HBox(\n        [left_widget, center_widget, right_widget],\n        layout=widgets.Layout(max_width=max_width, max_height=max_height),\n    )\n\n    search_widget = widgets.Text(\n        placeholder=\"Search tools ...\", layout=widgets.Layout(width=\"170px\")\n    )\n    label_widget = widgets.Label(layout=widgets.Layout(width=\"170px\"))\n    label_widget.value = f\"{len(tools_dict)} Available Tools\"\n    close_btn = widgets.Button(\n        description=\"Close Toolbox\", icon=\"close\", layout=widgets.Layout(width=\"170px\")\n    )\n\n    categories = {}\n    categories[\"All Tools\"] = []\n    for key in tools_dict.keys():\n        category = tools_dict[key][\"category\"]\n        if category not in categories.keys():\n            categories[category] = []\n        categories[category].append(tools_dict[key][\"name\"])\n        categories[\"All Tools\"].append(tools_dict[key][\"name\"])\n\n    options = list(categories.keys())\n    all_tools = categories[\"All Tools\"]\n    all_tools.sort()\n    category_widget = widgets.Select(\n        options=options, layout=widgets.Layout(width=\"170px\", height=\"175px\")\n    )\n    tools_widget = widgets.Select(\n        options=[], layout=widgets.Layout(width=\"195px\", height=\"400px\")\n    )\n\n    def category_selected(change):\n        if change[\"new\"]:\n            selected = change[\"owner\"].value\n            options = categories[selected]\n            options.sort()\n            tools_widget.options = options\n            label_widget.value = f\"{len(options)} Available Tools\"\n\n    category_widget.observe(category_selected, \"value\")\n\n    def tool_selected(change):\n        if change[\"new\"]:\n            selected = change[\"owner\"].value\n            tool_dict = tools_dict[selected]\n            with right_widget:\n                right_widget.clear_output()\n                display(\n                    tool_gui(\n                        tool_dict, max_height=max_height, sandbox_path=sandbox_path\n                    )\n                )\n\n    tools_widget.observe(tool_selected, \"value\")\n\n    def search_changed(change):\n        if change[\"new\"]:\n            keyword = change[\"owner\"].value\n            if len(keyword) &gt; 0:\n                selected_tools = []\n                for tool in all_tools:\n                    if (\n                        keyword.lower() in tool.lower()\n                        or keyword.lower() in tools_dict[tool][\"description\"]\n                    ):\n                        selected_tools.append(tool)\n                if len(selected_tools) &gt; 0:\n                    tools_widget.options = selected_tools\n                label_widget.value = f\"{len(selected_tools)} Available Tools\"\n        else:\n            tools_widget.options = all_tools\n            label_widget.value = f\"{len(tools_dict)} Available Tools\"\n\n    search_widget.observe(search_changed, \"value\")\n\n    def close_btn_clicked(b):\n        full_widget.close()\n\n    close_btn.on_click(close_btn_clicked)\n\n    category_widget.value = list(categories.keys())[0]\n    tools_widget.options = all_tools\n    left_widget.children = [category_widget,\n                            search_widget, label_widget, close_btn]\n    center_widget.children = [tools_widget]\n\n    return full_widget\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.build_toolbox_tree","title":"<code>build_toolbox_tree(tools_dict, folder_icon='folder', tool_icon='wrench', sandbox_path=None)</code>","text":"<p>Build the toolbox for WhiteboxTools.</p> <p>Parameters:</p> Name Type Description Default <code>tools_dict</code> <code>dict</code> <p>A dictionary containing information for all tools.</p> required <code>folder_icon</code> <code>str</code> <p>The font-awesome icon for tool categories. Defaults to \"folder\".</p> <code>'folder'</code> <code>tool_icon</code> <code>str</code> <p>The font-awesome icon for tools. Defaults to \"wrench\".</p> <code>'wrench'</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox folder. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget representing the toolbox.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def build_toolbox_tree(\n    tools_dict, folder_icon=\"folder\", tool_icon=\"wrench\", sandbox_path=None\n):\n\"\"\"Build the toolbox for WhiteboxTools.\n\n    Args:\n        tools_dict (dict): A dictionary containing information for all tools.\n        folder_icon (str, optional): The font-awesome icon for tool categories. Defaults to \"folder\".\n        tool_icon (str, optional): The font-awesome icon for tools. Defaults to \"wrench\".\n        sandbox_path (str, optional): The path to the sandbox folder. Defaults to None.\n\n    Returns:\n        object: An ipywidget representing the toolbox.\n    \"\"\"\n    left_widget = widgets.VBox()\n    right_widget = widgets.VBox()\n    full_widget = widgets.HBox([left_widget, right_widget])\n\n    search_description = f\"{len(tools_dict)} tools available. Search tools ...\"\n    search_box = widgets.Text(placeholder=search_description)\n    search_box.layout.width = \"270px\"\n\n    close_btn = widgets.Button(\n        icon=\"close\", layout=widgets.Layout(width=\"32px\"))\n\n    def close_btn_clicked(b):\n        full_widget.close()\n\n    close_btn.on_click(close_btn_clicked)\n\n    tree_widget = widgets.Output()\n    tree_widget.layout.max_width = \"310px\"\n    tree_widget.overflow = \"auto\"\n\n    left_widget.children = [widgets.HBox([search_box, close_btn]), tree_widget]\n    output = widgets.Output(layout=widgets.Layout(max_width=\"760px\"))\n    right_widget.children = [output]\n\n    tree = Tree(multiple_selection=False)\n    tree_dict = {}\n\n    def search_box_callback(text):\n\n        with tree_widget:\n            if text.value == \"\":\n                print(\"Loading...\")\n                tree_widget.clear_output(wait=True)\n                display(tree)\n            else:\n                tree_widget.clear_output()\n                print(\"Searching...\")\n                tree_widget.clear_output(wait=True)\n                sub_tree = search_api_tree(text.value, tree_dict, tools_dict)\n                display(sub_tree)\n\n    search_box.on_submit(search_box_callback)\n\n    root_name = \"WhiteboxTools\"\n    root_node = Node(root_name)\n    tree.add_node(root_node)\n\n    categories = {}\n\n    def handle_tool_clicked(event):\n        if event[\"new\"]:\n            cur_node = event[\"owner\"]\n            tool_name = cur_node.name\n            with output:\n                output.clear_output()\n                tool_ui = tool_gui(\n                    tools_dict[tool_name], sandbox_path=sandbox_path)\n                display(tool_ui)\n\n    for key in tools_dict.keys():\n        category = tools_dict[key][\"category\"]\n        if category not in categories.keys():\n            category_node = Node(category, icon=folder_icon, opened=False)\n            root_node.add_node(category_node)\n            categories[category] = category_node\n            tool_node = Node(key, icon=tool_icon)\n            category_node.add_node(tool_node)\n            tree_dict[key] = tool_node\n            tool_node.observe(handle_tool_clicked, \"selected\")\n        else:\n            category_node = categories[category]\n            tool_node = Node(key, icon=tool_icon)\n            category_node.add_node(tool_node)\n            tree_dict[key] = tool_node\n            tool_node.observe(handle_tool_clicked, \"selected\")\n\n    with tree_widget:\n        tree_widget.clear_output()\n        display(tree)\n\n    return full_widget\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.clone_repo","title":"<code>clone_repo(out_dir='.', unzip=True)</code>","text":"<p>Clones the whiteboxgui GitHub repository.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>Output folder for the repo. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the repository. Defaults to True.</p> <code>True</code> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def clone_repo(out_dir=\".\", unzip=True):\n\"\"\"Clones the whiteboxgui GitHub repository.\n\n    Args:\n        out_dir (str, optional): Output folder for the repo. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the repository. Defaults to True.\n    \"\"\"\n    url = \"https://github.com/opengeos/whiteboxgui/archive/master.zip\"\n    filename = \"whiteboxgui-master.zip\"\n    download_from_url(url, out_file_name=filename,\n                      out_dir=out_dir, unzip=unzip)\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.create_code_cell","title":"<code>create_code_cell(code='', where='below')</code>","text":"<p>Creates a code cell in the IPython Notebook.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to fill the new code cell with. Defaults to ''.</p> <code>''</code> <code>where</code> <code>str</code> <p>Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.</p> <code>'below'</code> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def create_code_cell(code=\"\", where=\"below\"):\n\"\"\"Creates a code cell in the IPython Notebook.\n\n    Args:\n        code (str, optional): Code to fill the new code cell with. Defaults to ''.\n        where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'.\n    \"\"\"\n\n    import base64\n    from IPython.display import Javascript, display\n\n    encoded_code = (base64.b64encode(str.encode(code))).decode()\n    display(\n        Javascript(\n\"\"\"\n        var code = IPython.notebook.insert_cell_{0}('code');\n        code.set_text(atob(\"{1}\"));\n    \"\"\".format(\n                where, encoded_code\n            )\n        )\n    )\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.download_from_url","title":"<code>download_from_url(url, out_file_name=None, out_dir='.', unzip=True, verbose=False)</code>","text":"<p>Download a file from a URL (e.g., https://github.com/opengeos/whitebox/raw/master/examples/testdata.zip)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The HTTP URL to download.</p> required <code>out_file_name</code> <code>str</code> <p>The output file name to use. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>str</code> <p>The output directory to use. Defaults to '.'.</p> <code>'.'</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file if it is a zip file. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether to display or not the output of the function. Defaults to False.</p> <code>False</code> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def download_from_url(url, out_file_name=None, out_dir=\".\", unzip=True, verbose=False):\n\"\"\"Download a file from a URL (e.g., https://github.com/opengeos/whitebox/raw/master/examples/testdata.zip)\n\n    Args:\n        url (str): The HTTP URL to download.\n        out_file_name (str, optional): The output file name to use. Defaults to None.\n        out_dir (str, optional): The output directory to use. Defaults to '.'.\n        unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True.\n        verbose (bool, optional): Whether to display or not the output of the function. Defaults to False.\n    \"\"\"\n    import tarfile\n    import urllib.request\n    import zipfile\n\n    in_file_name = os.path.basename(url)\n\n    if out_file_name is None:\n        out_file_name = in_file_name\n    out_file_path = os.path.join(os.path.abspath(out_dir), out_file_name)\n\n    if verbose:\n        print(\"Downloading {} ...\".format(url))\n\n    try:\n        urllib.request.urlretrieve(url, out_file_path)\n    except Exception:\n        raise Exception(\"The URL is invalid. Please double check the URL.\")\n\n    final_path = out_file_path\n\n    if unzip:\n        # if it is a zip file\n        if \".zip\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with zipfile.ZipFile(out_file_path, \"r\") as zip_ref:\n                zip_ref.extractall(out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".zip\", \"\")\n            )\n\n        # if it is a tar file\n        if \".tar\" in out_file_name:\n            if verbose:\n                print(\"Unzipping {} ...\".format(out_file_name))\n            with tarfile.open(out_file_path, \"r\") as tar_ref:\n                def is_within_directory(directory, target):\n\n                    abs_directory = os.path.abspath(directory)\n                    abs_target = os.path.abspath(target)\n\n                    prefix = os.path.commonprefix([abs_directory, abs_target])\n\n                    return prefix == abs_directory\n\n                def safe_extract(tar, path=\".\", members=None, *, numeric_owner=False):\n\n                    for member in tar.getmembers():\n                        member_path = os.path.join(path, member.name)\n                        if not is_within_directory(path, member_path):\n                            raise Exception(\"Attempted Path Traversal in Tar File\")\n\n                    tar.extractall(path, members, numeric_owner=numeric_owner) \n\n\n                safe_extract(tar_ref, out_dir)\n            final_path = os.path.join(\n                os.path.abspath(out_dir), out_file_name.replace(\".tart\", \"\")\n            )\n\n    if verbose:\n        print(\"Data downloaded to: {}\".format(final_path))\n\n    return\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_book_url","title":"<code>get_book_url(tool_name, category)</code>","text":"<p>Get the link to the help documentation of the tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>The name of the tool.</p> required <code>category</code> <code>str</code> <p>The category of the tool.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The URL to help documentation.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def get_book_url(tool_name, category):\n\"\"\"Get the link to the help documentation of the tool.\n\n    Args:\n        tool_name (str): The name of the tool.\n        category (str): The category of the tool.\n\n    Returns:\n        str: The URL to help documentation.\n    \"\"\"\n    prefix = \"https://www.whiteboxgeo.com/manual/wbt_book/available_tools\"\n    if category == \"Math and Stats Tools\":\n        category = \"Mathand Stats Tools\"\n    url = \"{}/{}.html#{}\".format(\n        prefix, category.lower().replace(\" \", \"_\"), to_camelcase(tool_name)\n    )\n\n    return url\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_ext_dict","title":"<code>get_ext_dict(verbose=True, reset=False)</code>","text":"<p>Generate a dictionary containing information for the general extension tools.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to print out description info. Defaults to True.</p> <code>True</code> <code>reset</code> <code>bool</code> <p>Whether to recreate the json file containing the dictionary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary containing information for general extension tools.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def get_ext_dict(verbose=True, reset=False):\n\"\"\"Generate a dictionary containing information for the general extension tools.\n\n    Args:\n        verbose (bool, optional): Whether to print out description info. Defaults to True.\n        reset (bool, optional): Whether to recreate the json file containing the dictionary. Defaults to False.\n\n    Returns:\n        dict: The dictionary containing information for general extension tools.\n    \"\"\"\n    import glob\n    import shutil\n    import urllib\n    import zipfile\n\n    os_links = {\n        \"Windows\": \"https://www.whiteboxgeo.com/GTE_Windows/GeneralToolsetExtension_win.zip\",\n        \"Darwin\": \"https://www.whiteboxgeo.com/GTE_Darwin/GeneralToolsetExtension_MacOS_Intel.zip\",\n        \"Linux\": \"https://www.whiteboxgeo.com/GTE_Linux/GeneralToolsetExtension_linux.zip\",\n    }\n\n    pkg_dir = os.path.dirname(\n        pkg_resources.resource_filename(\"whitebox\", \"whitebox.py\")\n    )\n\n    plugin_dir = os.path.join(pkg_dir, \"plugins\")\n    ext_dir = os.path.join(pkg_dir, \"GeneralToolsetExtension\")\n\n    url = os_links[platform.system()]\n    zip_name = os.path.join(pkg_dir, os.path.basename(url))\n\n    if reset:\n        if os.path.exists(zip_name):\n            os.remove(zip_name)\n\n    if not os.path.exists(zip_name):\n        if verbose:\n            print(\"Downloading General Toolset Extension, please wait ...\")\n        request = urllib.request.urlopen(url, timeout=500)\n        with open(zip_name, \"wb\") as f:\n            f.write(request.read())\n\n        if verbose:\n            print(\"Decompressing {} ...\".format(os.path.basename(url)))\n        with zipfile.ZipFile(zip_name, \"r\") as zip_ref:\n            zip_ref.extractall(pkg_dir)\n\n        shutil.copytree(ext_dir, plugin_dir, dirs_exist_ok=True)\n        shutil.rmtree(ext_dir)\n\n    files = glob.glob(os.path.join(plugin_dir, \"*.json\"))\n    files.sort()\n\n    ext_dict = {}\n\n    for file in files:\n        tool_dict = {}\n        with open(file, encoding='utf-8') as f:\n            tool = json.load(f)\n        name = tool[\"exe\"]\n        tool_dict[\"name\"] = tool[\"tool_name\"]\n        tool_dict[\"tool_name\"] = name\n        tool_dict[\"category\"] = tool[\"toolbox\"].split(\"/\")[0]\n        tool_dict[\"label\"] = to_label(name)\n        tool_dict[\"description\"] = tool[\"short_description\"]\n        tool_dict[\"github\"] = get_github_url(name)\n        tool_dict[\"book\"] = get_book_url(name, tool[\"toolbox\"])\n\n        params_dict = {}\n        params = tool[\"parameters\"]\n        for param in params:\n            flags = param[\"flags\"]\n            if isinstance(flags, list):\n                if flags == [\"-i\", \"--input\"]:\n                    flag = \"i\"\n                else:\n                    flag = flags[-1].replace(\"-\", \"\")\n            else:\n                flag = flags.replace(\"-\", \"\")\n            params_dict[flag] = param\n        tool_dict[\"parameters\"] = params_dict\n\n        ext_dict[tool[\"tool_name\"]] = tool_dict\n\n    return ext_dict\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_github_url","title":"<code>get_github_url(tool_name)</code>","text":"<p>Get the link to the source code of the tool on GitHub.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>The name of the tool.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The URL to source code.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def get_github_url(tool_name):\n\"\"\"Get the link to the source code of the tool on GitHub.\n\n    Args:\n        tool_name (str): The name of the tool.\n\n    Returns:\n        str: The URL to source code.\n    \"\"\"\n    print(tool_name)\n    url = wbt.view_code(tool_name).strip()\n    if \"RUST_BACKTRACE\" in url:\n        url = \"https://github.com/jblindsay/whitebox-tools/tree/master/whitebox-tools-app/src/tools\"\n    return url\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_tool_params","title":"<code>get_tool_params(tool_name)</code>","text":"<p>Get parameters for a tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>The name of the tool.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The tool parameters as a dictionary.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def get_tool_params(tool_name):\n\"\"\"Get parameters for a tool.\n\n    Args:\n        tool_name (str): The name of the tool.\n\n    Returns:\n        dict: The tool parameters as a dictionary.\n    \"\"\"\n    params_dict = {}\n    params = json.loads(wbt.tool_parameters(\n        tool_name).replace(\"\\n\", \"\"))[\"parameters\"]\n    for param in params:\n        flags = param[\"flags\"]\n        if isinstance(flags, list):\n            if flags == [\"-i\", \"--input\"]:\n                flag = \"i\"\n            else:\n                flag = flags[-1].replace(\"-\", \"\")\n        else:\n            flag = flags.replace(\"-\", \"\")\n        params_dict[flag] = param\n    return params_dict\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_wbt_dict","title":"<code>get_wbt_dict(reset=False)</code>","text":"<p>Generate a dictionary containing information for all tools.</p> <p>Parameters:</p> Name Type Description Default <code>reset</code> <code>bool</code> <p>Whether to recreate the json file containing the dictionary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary containing information for all tools.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def get_wbt_dict(reset=False):\n\"\"\"Generate a dictionary containing information for all tools.\n\n    Args:\n        reset (bool, optional): Whether to recreate the json file containing the dictionary. Defaults to False.\n\n    Returns:\n        dict: The dictionary containing information for all tools.\n    \"\"\"\n    pkg_dir = os.path.dirname(\n        pkg_resources.resource_filename(\"whiteboxgui\", \"whiteboxgui.py\")\n    )\n\n    wbt_dict_json = os.path.join(pkg_dir, \"data/whitebox_tools.json\")\n\n    if (not os.path.exists(wbt_dict_json)) or reset:\n\n        wbt_dict = {}\n        tools = wbt.list_tools()\n\n        category_dict = tool_categories()\n\n        for tool in tools.keys():\n            tool_dict = {}\n            name = to_snakecase(tool)\n            tool_dict[\"name\"] = to_camelcase(name)\n            tool_dict[\"tool_name\"] = name\n            tool_dict[\"category\"] = category_dict[name]\n            tool_dict[\"label\"] = to_label(name)\n            tool_dict[\"description\"] = tools[tool]\n            tool_dict[\"github\"] = get_github_url(name)\n            tool_dict[\"book\"] = get_book_url(name, category_dict[name])\n            tool_dict[\"parameters\"] = get_tool_params(name)\n\n            wbt_dict[to_camelcase(name)] = tool_dict\n\n        wbt_dict.update(get_ext_dict())\n\n        with open(wbt_dict_json, \"w\", encoding='utf-8') as fp:\n            json.dump(wbt_dict, fp, indent=4)\n    else:\n\n        with open(wbt_dict_json, encoding='utf-8') as fp:\n            wbt_dict = json.load(fp)\n\n    return wbt_dict\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.in_colab_shell","title":"<code>in_colab_shell()</code>","text":"<p>Tests if the code is being executed within Google Colab.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def in_colab_shell():\n\"\"\"Tests if the code is being executed within Google Colab.\"\"\"\n    import sys\n\n    if \"google.colab\" in sys.modules:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.search_api_tree","title":"<code>search_api_tree(keywords, api_tree, tools_dict)</code>","text":"<p>Search the WhiteboxTools API and return functions containing the specified keywords</p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>str</code> <p>The keywords to search for.</p> required <code>api_tree</code> <code>dict</code> <p>The dictionary containing the WhiteboxTools API tree.</p> required <code>tools_dict</code> <code>dict</code> <p>The dictionary containing the dict of all tools.</p> required <p>Returns:</p> Type Description <code>object</code> <p>An ipytree object/widget.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def search_api_tree(keywords, api_tree, tools_dict):\n\"\"\"Search the WhiteboxTools API and return functions containing the specified keywords\n\n    Args:\n        keywords (str): The keywords to search for.\n        api_tree (dict): The dictionary containing the WhiteboxTools API tree.\n        tools_dict (dict): The dictionary containing the dict of all tools.\n\n    Returns:\n        object: An ipytree object/widget.\n    \"\"\"\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n\n    sub_tree = Tree()\n    for key in api_tree.keys():\n        if (keywords.lower() in key.lower()) or (\n            keywords.lower() in tools_dict[key][\"description\"].lower()\n        ):\n            sub_tree.add_node(api_tree[key])\n\n    return sub_tree\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.show","title":"<code>show(verbose=True, tree=False, reset=False, sandbox_path=None)</code>","text":"<p>Show the toolbox GUI.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to show progress info when the tool is running. Defaults to True.</p> <code>True</code> <code>tree</code> <code>bool</code> <p>Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.</p> <code>False</code> <code>reset</code> <code>bool</code> <p>Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.</p> <code>False</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>A toolbox GUI.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def show(verbose=True, tree=False, reset=False, sandbox_path=None):\n\"\"\"Show the toolbox GUI.\n\n    Args:\n        verbose (bool, optional): Whether to show progress info when the tool is running. Defaults to True.\n        tree (bool, optional): Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False.\n        reset (bool, optional): Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False.\n        sandbox_path (str, optional): The path to the sandbox directory. Defaults to None.\n    Returns:\n        object: A toolbox GUI.\n    \"\"\"\n    tools_dict = get_wbt_dict(reset=reset)\n\n    if verbose:\n        wbt.verbose = True\n    else:\n        wbt.verbose = False\n\n    # if in_colab_shell():\n    #     tree = False\n\n    if tree:\n        return build_toolbox_tree(tools_dict, sandbox_path=sandbox_path)\n    else:\n        return build_toolbox(tools_dict, sandbox_path=sandbox_path)\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.to_camelcase","title":"<code>to_camelcase(name)</code>","text":"<p>Convert snake_case name to CamelCase name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The CamelCase name of the tool.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def to_camelcase(name):\n\"\"\"Convert snake_case name to CamelCase name.\n\n    Args:\n        name (str): The name of the tool.\n\n    Returns:\n        str: The CamelCase name of the tool.\n    \"\"\"\n\n    return \"\".join(x.title() for x in name.split(\"_\"))\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.to_label","title":"<code>to_label(name)</code>","text":"<p>Convert snake_case name to Title case label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The Title case name of the tool.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def to_label(name):\n\"\"\"Convert snake_case name to Title case label.\n\n    Args:\n        name (str): The name of the tool.\n\n    Returns:\n        str: The Title case name of the tool.\n    \"\"\"\n    return \" \".join(x.title() for x in name.split(\"_\"))\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.to_snakecase","title":"<code>to_snakecase(name)</code>","text":"<p>Convert CamelCase name to snake_case name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tool.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The snakecase name of the tool.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def to_snakecase(name):\n\"\"\"Convert CamelCase name to snake_case name.\n\n    Args:\n        name (str): The name of the tool.\n\n    Returns:\n        str: The snakecase name of the tool.\n    \"\"\"\n    s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.tool_categories","title":"<code>tool_categories()</code>","text":"<p>Generate a dictionary containing the toolbox corresponds to each tool.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary containing the toolbox corresponds to each tool.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def tool_categories():\n\"\"\"Generate a dictionary containing the toolbox corresponds to each tool.\n\n    Returns:\n        dict: a dictionary containing the toolbox corresponds to each tool.\n    \"\"\"\n    category_dict = {}\n    tools = wbt.toolbox().split(\"\\n\")\n    for tool in tools[:-1]:\n        name = tool.split(\":\")[0]\n        category = tool.split(\":\")[1].strip().split(\"/\")[0]\n        category_dict[to_snakecase(name)] = category\n\n    return category_dict\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.tool_gui","title":"<code>tool_gui(tool_dict, max_width='420px', max_height='600px', sandbox_path=None)</code>","text":"<p>Create a GUI for a tool based on the tool dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>tool_dict</code> <code>dict</code> <p>The dictionary containing the tool info.</p> required <code>max_width</code> <code>str</code> <p>The max width of the tool dialog.</p> <code>'420px'</code> <code>max_height</code> <code>str</code> <p>The max height of the tool dialog.</p> <code>'600px'</code> <code>sandbox_path</code> <code>str</code> <p>The path to the sandbox directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>An ipywidget object representing the tool interface.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def tool_gui(tool_dict, max_width=\"420px\", max_height=\"600px\", sandbox_path=None):\n\"\"\"Create a GUI for a tool based on the tool dictionary.\n\n    Args:\n        tool_dict (dict): The dictionary containing the tool info.\n        max_width (str, optional): The max width of the tool dialog.\n        max_height (str, optional): The max height of the tool dialog.\n        sandbox_path (str, optional): The path to the sandbox directory. Defaults to None.\n\n    Returns:\n        object: An ipywidget object representing the tool interface.\n    \"\"\"\n    tool_widget = widgets.VBox(\n        layout=widgets.Layout(max_width=max_width, max_height=max_height)\n    )\n    children = []\n    args = {}\n    required_inputs = []\n    style = {\"description_width\": \"initial\"}\n    max_width = str(int(max_width.replace(\"px\", \"\")) - 10) + \"px\"\n\n    header_width = str(int(max_width.replace(\"px\", \"\")) - 104) + \"px\"\n    header = widgets.Label(\n        value=f'Current Tool: {tool_dict[\"name\"]}',\n        style=style,\n        layout=widgets.Layout(width=header_width),\n    )\n    code_btn = widgets.Button(\n        description=\"View Code\", layout=widgets.Layout(width=\"100px\")\n    )\n\n    children.append(widgets.HBox([header, code_btn]))\n\n    desc = widgets.Textarea(\n        value=f'Description: {tool_dict[\"description\"]}',\n        layout=widgets.Layout(width=\"410px\", max_width=max_width),\n        disabled=True,\n    )\n    children.append(desc)\n\n    params = tool_dict[\"parameters\"]\n    for param in params:\n        items = params[param]\n        required = \"\"\n        if items[\"optional\"] == \"false\" or (not items[\"optional\"]):\n            required = \"*\"\n            required_inputs.append(param)\n        label = items[\"name\"] + required\n        param_type = items[\"parameter_type\"]\n        default_value = None\n\n        if items[\"default_value\"] is not None:\n\n            if (items[\"default_value\"] != \"null\") and (len(items[\"default_value\"]) &gt; 0):\n                if \"false\" in items[\"default_value\"]:\n                    default_value = False\n                elif \"true\" in items[\"default_value\"]:\n                    default_value = True\n                else:\n                    default_value = items[\"default_value\"].replace('\"', \"\")\n\n        layout = widgets.Layout(width=\"500px\", max_width=max_width)\n\n        if isinstance(param_type, str):\n            # display(data_types[param_type])\n\n            if param_type == \"Boolean\":\n                var_widget = widgets.Checkbox(\n                    description=label, style=style, layout=layout, value=default_value\n                )\n            elif param_type in [\n                \"Directory\",\n                \"ExistingFile\",\n                \"ExistingFileOrFloat\",\n                \"FileList\",\n                \"NewFile\",\n            ]:\n                var_widget = FileChooser(\n                    title=label, sandbox_path=sandbox_path)\n            else:\n                var_widget = widgets.Text(\n                    description=label, style=style, layout=layout)\n                if default_value is not None:\n                    var_widget.value = str(default_value)\n\n            args[param] = var_widget\n\n            children.append(var_widget)\n        elif isinstance(param_type, dict):\n\n            if \"OptionList\" in param_type:\n                var_widget = widgets.Dropdown(\n                    options=param_type[\"OptionList\"],\n                    description=label,\n                    style=style,\n                    layout=layout,\n                )\n            elif list(param_type.keys())[0] in [\n                \"Directory\",\n                \"ExistingFile\",\n                \"ExistingFileOrFloat\",\n                \"FileList\",\n                \"NewFile\",\n            ]:\n                var_widget = FileChooser(\n                    title=label, sandbox_path=sandbox_path)\n            else:\n                var_widget = FileChooser(\n                    title=label, sandbox_path=sandbox_path)\n            args[param] = var_widget\n\n            children.append(var_widget)\n\n    run_btn = widgets.Button(\n        description=\"Run\", layout=widgets.Layout(width=\"100px\"))\n    cancel_btn = widgets.Button(\n        description=\"Cancel\", layout=widgets.Layout(width=\"100px\")\n    )\n    help_btn = widgets.Button(\n        description=\"Help\", layout=widgets.Layout(width=\"100px\"))\n    import_btn = widgets.Button(\n        description=\"Import\",\n        tooltip=\"Import the script to a new cell\",\n        layout=widgets.Layout(width=\"98px\"),\n    )\n    tool_output = widgets.Output(\n        layout=widgets.Layout(max_height=\"200px\", overflow=\"scroll\")\n    )\n    children.append(widgets.HBox([run_btn, cancel_btn, help_btn, import_btn]))\n    children.append(tool_output)\n    tool_widget.children = children\n\n    def run_button_clicked(b):\n        tool_output.clear_output()\n\n        required_params = required_inputs.copy()\n        args2 = []\n        for arg in args:\n\n            line = \"\"\n            if isinstance(args[arg], FileChooser):\n                if arg in required_params and args[arg].selected is None:\n                    with tool_output:\n                        print(f\"Please provide inputs for required parameters.\")\n                        break\n                elif arg in required_params:\n                    required_params.remove(arg)\n                if args[arg].selected is not None:\n                    if arg == \"i\":\n                        line = f\"-{arg}={args[arg].selected}\"\n                    else:\n                        line = f\"--{arg}={args[arg].selected}\"\n            elif isinstance(args[arg], widgets.Text):\n                if arg in required_params and len(args[arg].value) == 0:\n                    with tool_output:\n                        print(f\"Please provide inputs for required parameters.\")\n                        break\n                elif arg in required_params:\n                    required_params.remove(arg)\n                if args[arg].value is not None and len(args[arg].value) &gt; 0:\n                    line = f\"--{arg}={args[arg].value}\"\n            elif isinstance(args[arg], widgets.Checkbox):\n                line = f\"--{arg}={args[arg].value}\"\n\n            args2.append(line)\n\n        if len(required_params) == 0:\n            with tool_output:\n                wbt.run_tool(tool_dict[\"name\"], args2)\n\n    def help_button_clicked(b):\n        import webbrowser\n\n        tool_output.clear_output()\n        with tool_output:\n            html = widgets.HTML(\n                value=f'&lt;a href={tool_dict[\"book\"]} target=\"_blank\"&gt;{tool_dict[\"book\"]}&lt;/a&gt;'\n            )\n            display(html)\n        webbrowser.open_new_tab(tool_dict[\"book\"])\n\n    def code_button_clicked(b):\n        import webbrowser\n\n        with tool_output:\n            if \"RUST_BACKTRACE\" in tool_dict[\"github\"]:\n                tool_dict[\n                    \"github\"\n                ] = \"https://github.com/jblindsay/whitebox-tools/tree/master/whitebox-tools-app/src/tools\"\n            html = widgets.HTML(\n                value=f'&lt;a href={tool_dict[\"github\"]} target=\"_blank\"&gt;{tool_dict[\"github\"]}&lt;/a&gt;'\n            )\n            display(html)\n        webbrowser.open_new_tab(tool_dict[\"github\"])\n\n    def cancel_btn_clicked(b):\n        tool_output.clear_output()\n\n    def import_button_clicked(b):\n        tool_output.clear_output()\n\n        required_params = required_inputs.copy()\n        args2 = []\n        args3 = []\n\n        for arg in args:\n\n            line = \"\"\n            if isinstance(args[arg], FileChooser):\n                if arg in required_params and args[arg].selected is None:\n                    with tool_output:\n                        print(f\"Please provide inputs for required parameters.\")\n                        break\n                elif arg in required_params:\n                    required_params.remove(arg)\n                if arg == \"i\":\n                    line = f\"-{arg}={args[arg].selected}\"\n                else:\n                    line = f\"--{arg}={args[arg].selected}\"\n                if args[arg].selected is not None:\n                    args3.append(f\"{arg}='{args[arg].selected}'\")\n            elif isinstance(args[arg], widgets.Text):\n                if arg in required_params and len(args[arg].value) == 0:\n                    with tool_output:\n                        print(f\"Please provide inputs for required parameters.\")\n                        break\n                elif arg in required_params:\n                    required_params.remove(arg)\n                if args[arg].value is not None and len(args[arg].value) &gt; 0:\n                    line = f\"--{arg}={args[arg].value}\"\n                    args3.append(f\"{arg}='{args[arg].value}'\")\n            elif isinstance(args[arg], widgets.Checkbox):\n                line = f\"--{arg}={args[arg].value}\"\n                args3.append(f\"{arg}={args[arg].value}\")\n            args2.append(line)\n\n        if len(required_params) == 0:\n            content = []\n            content.append(\"import whitebox\")\n            content.append(\"wbt = whitebox.WhiteboxTools()\")\n            content.append(\n                f\"wbt.{to_snakecase(tool_dict['name'])}({', '.join(args3)})\")\n            with tool_output:\n                for line in content:\n                    print(line)\n            create_code_cell(\"\\n\".join(content))\n\n    import_btn.on_click(import_button_clicked)\n    run_btn.on_click(run_button_clicked)\n    help_btn.on_click(help_button_clicked)\n    code_btn.on_click(code_button_clicked)\n    cancel_btn.on_click(cancel_btn_clicked)\n\n    return tool_widget\n</code></pre>"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.update_package","title":"<code>update_package()</code>","text":"<p>Updates the whiteboxgui package from the GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.</p> Source code in <code>whiteboxgui/whiteboxgui.py</code> <pre><code>def update_package():\n\"\"\"Updates the whiteboxgui package from the GitHub repository without the need to use pip or conda.\n    In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package.\n\n    \"\"\"\n    import shutil\n\n    try:\n        download_dir = os.getcwd()\n        clone_repo(out_dir=download_dir)\n\n        pkg_dir = os.path.join(download_dir, \"whiteboxgui-master\")\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n\n        if shutil.which(\"pip\") is None:\n            cmd = \"pip3 install .\"\n        else:\n            cmd = \"pip install .\"\n\n        os.system(cmd)\n        os.chdir(work_dir)\n        os.remove(pkg_dir + \".zip\")\n        shutil.rmtree(pkg_dir)\n\n        print(\n            \"\\nPlease comment out 'whiteboxgui.update_package()' and restart the kernel to take effect:\\nJupyter menu -&gt; Kernel -&gt; Restart &amp; Clear Output\"\n        )\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"examples/examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>import subprocess\n\ntry:\n    import whiteboxgui\nexcept ImportError:\n    print('Installing whiteboxgui ...')\n    subprocess.check_call([\"python\", '-m', 'pip', 'install', 'whiteboxgui'])\n</pre> import subprocess  try:     import whiteboxgui except ImportError:     print('Installing whiteboxgui ...')     subprocess.check_call([\"python\", '-m', 'pip', 'install', 'whiteboxgui']) In\u00a0[2]: Copied! <pre>import whiteboxgui\n</pre> import whiteboxgui In\u00a0[3]: Copied! <pre>whiteboxgui.show()\n</pre> whiteboxgui.show() Out[3]: In\u00a0[4]: Copied! <pre>whiteboxgui.show(tree=True)\n</pre> whiteboxgui.show(tree=True) Out[4]:"}]}